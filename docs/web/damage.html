<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>ダメージ計算ツール</title>
  <link rel="stylesheet" href="../theme.css?v4" />
  <style>
    .form-sections {
      display: grid;
      gap: 12px;
    }

    .input-card {
      padding: 12px;
      border-radius: 12px;
      display: grid;
      gap: 12px;
    }

    .input-card h4 {
      margin: 0;
    }

    .result-panel {
      position: sticky;
      top: 8px;
      z-index: 5;
      margin-top: 10px;
      margin-bottom: 14px;
    }

    .result-summary {
      cursor: pointer;
      user-select: none;
    }

    .result-summary:focus-visible {
      outline: 2px solid var(--md-sys-primary);
      outline-offset: 2px;
    }

    .result-detail-panel {
      margin-top: 8px;
      display: grid;
      gap: 8px;
    }

    .result-divider {
      margin-top: 6px;
      padding-top: 8px;
    }

    .result-detail-value {
      font-size: 0.95rem;
      font-weight: 700;
      text-align: right;
    }

    .chip-button[data-value="physical"] {
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface);
      border-color: #f2f2f2;
    }

    .chip-button[data-value="element"] {
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface);
      border-color: #e85757;
    }

    .chip-button[data-value="void"] {
      background: var(--md-sys-surface);
      color: var(--md-sys-on-surface-variant);
      border-color: #8a8a8a;
    }

    .chip-button.is-active[data-value="physical"] {
      background: color-mix(in srgb, #ffffff 70%, var(--md-sys-surface));
      color: #1a1b21;
      box-shadow: 0 0 0 1px color-mix(in srgb, #ffffff 70%, transparent);
    }

    .chip-button.is-active[data-value="element"] {
      background: linear-gradient(135deg, rgba(232, 87, 87, 0.8), rgba(81, 142, 255, 0.8));
      color: #130505;
      border-color: transparent;
      box-shadow: 0 0 0 1px color-mix(in srgb, #e85757 60%, transparent);
    }

    .chip-button.is-active[data-value="void"] {
      background: color-mix(in srgb, #8a8a8a 70%, var(--md-sys-surface));
      color: #151515;
      box-shadow: 0 0 0 1px color-mix(in srgb, #8a8a8a 70%, transparent);
    }

    .formula-table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid var(--md-sys-outline-variant);
      border-radius: 12px;
      overflow: hidden;
      background: var(--md-sys-surface);
    }

    .formula-table th,
    .formula-table td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--md-sys-outline-variant);
      text-align: left;
      vertical-align: top;
      font-size: 0.92rem;
      line-height: 1.5;
    }

    .formula-table tr:last-child th,
    .formula-table tr:last-child td {
      border-bottom: none;
    }

    .formula-table th {
      width: 180px;
      color: var(--md-sys-on-surface-variant);
      font-weight: 600;
      background: color-mix(in srgb, var(--md-sys-surface) 90%, var(--md-sys-primary-container));
    }

    .formula-note {
      margin: 8px 0 0;
      color: var(--md-sys-on-surface-variant);
      font-size: 0.88rem;
    }

    @media (max-width: 640px) {
      .formula-table th {
        width: 120px;
      }
    }

    @media (min-width: 960px) {
      .form-sections {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .input-card--skill {
        grid-column: 1 / -1;
      }
    }
  </style>
</head>

<body>
  <main>
    <header class="reveal">
      <p class="subtitle">Eldersign Toolkit</p>
      <h1>ダメージ計算ツール</h1>
      <p class="subtitle">仮置き。行動順と自動入力を後で入れたい</p>
      <div class="nav-links">
        <a class="button secondary" href="../index.html">ツール集へ戻る</a>
      </div>
    </header>

    <section class="reveal">
      <div class="result-panel">
        <div class="result-card">
          <div class="result-summary" id="result-summary" role="button" tabindex="0" aria-expanded="false"
            aria-controls="result-detail-panel">
          <div class="result-row">
            <div class="result-label">ダメージ(乱数前)</div>
            <div class="result-value" id="atk-damage-base">-</div>
          </div>
          <div class="result-row">
            <div class="result-label">乱数範囲</div>
            <div class="result-value" id="atk-damage-range">-</div>
          </div>
          <div class="result-row">
            <div class="result-label">命中率</div>
            <div class="result-value" id="hit-raw">-</div>
          </div>
          </div>
          <div class="divider result-divider result-detail-panel is-hidden" id="result-detail-panel">
            <div class="result-row mode-attack">
              <div class="result-label">スキル強度</div>
              <div class="result-detail-value" id="detail-skill-power">-</div>
            </div>
            <div class="result-row mode-attack">
              <div class="result-label">防御強度</div>
              <div class="result-detail-value" id="detail-def-power">-</div>
            </div>
            <div class="result-row mode-attack">
              <div class="result-label">ダメージ補正内訳</div>
              <div class="result-detail-value" id="detail-damage-meta">-</div>
            </div>
            <div class="result-row mode-attack">
              <div class="result-label">ユニオン補正</div>
              <div class="result-detail-value" id="detail-union-meta">-</div>
            </div>
            <div class="result-row mode-heal is-hidden">
              <div class="result-label">回復補正内訳</div>
              <div class="result-detail-value" id="detail-heal-meta">-</div>
            </div>
            <div class="result-row">
              <div class="result-label">命中計算内訳</div>
              <div class="result-detail-value" id="detail-hit-meta">-</div>
            </div>
          </div>
        </div>
      </div>
      <div class="form-sections">
        <div class="input-card surface-card input-card--skill">
          <h4>スキル性能</h4>
          <div class="input-row">
              <label for="skill-type">種別</label>
              <input type="hidden" id="skill-type" value="attack" />
              <div class="chip-group" data-chip-target="skill-type">
                <button type="button" class="chip-button is-active" data-value="attack">攻撃・吸収</button>
                <button type="button" class="chip-button" data-value="heal">付与・回復</button>
              </div>
          </div>
          <div class="input-row">
              <label for="skill-coeff">係数</label>
              <input id="skill-coeff" type="number" min="0" step="0.1" value="100" />
          </div>
          <div class="input-row">
              <label for="hit-skill">命中</label>
              <input id="hit-skill" type="number" min="0" step="1" value="120" />
            </div>
            <div class="input-row">
              <label for="skill-source">ソース(複数はカンマ区切り)</label>
              <input id="skill-source" type="text" placeholder="例: 1200, 1500" />
            </div>
          <div class="input-row mode-attack">
              <label for="skill-attr">属性</label>
              <input type="hidden" id="skill-attr" value="physical" />
              <div class="chip-group" data-chip-target="skill-attr">
                <button type="button" class="chip-button is-active" data-value="physical">物理</button>
                <button type="button" class="chip-button" data-value="element">炎冷</button>
                <button type="button" class="chip-button" data-value="void">虚軸</button>
              </div>
          </div>
        </div>

        <div class="input-card surface-card">
          <h4>攻撃側ステータス</h4>
          <div class="input-row">
              <label for="skill-apt-passive">P適正(%)</label>
              <input id="skill-apt-passive" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-apt-active">A適正(%)</label>
              <input id="skill-apt-active" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-buff">強化(%)</label>
              <input id="skill-buff" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-seal">封技/封術Lv</label>
              <input id="skill-seal" type="number" min="0" max="10" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="hit-attacker">命中</label>
              <input id="hit-attacker" type="number" min="0" step="1" value="0" />
            </div>
          <div class="input-row">
              <label for="hit-dizzy-attacker">眩暈Lv</label>
              <input id="hit-dizzy-attacker" type="number" min="0" max="10" step="1" value="0" />
          </div>
          <label class="toggle-item">
              <input id="hit-after" type="checkbox" />
              <span>後攻補正 +100%</span>
          </label>
          <label class="toggle-item">
              <input id="hit-monarch" type="checkbox" />
              <span>君主補正 +50%</span>
          </label>
          <label class="toggle-item">
              <input id="hit-eye" type="checkbox" />
              <span>アビリティ神眼(上限99/下限30)</span>
          </label>
        </div>

        <div class="input-card surface-card">
          <h4>防御側ステータス</h4>
          <div class="input-row mode-attack">
              <label for="def-value">防御</label>
              <input id="def-value" type="number" min="0" step="1" value="3000" />
          </div>
          <div class="input-row">
              <label for="skill-resist-passive">P耐性(%)</label>
              <input id="skill-resist-passive" type="number" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="skill-resist-active">A耐性(%)</label>
              <input id="skill-resist-active" type="number" step="1" value="0" />
          </div>
          <div class="input-row mode-attack">
              <label for="def-alert">隙</label>
              <input id="def-alert" type="number" min="0" max="100" step="1" value="0" />
          </div>
          <div class="input-row mode-attack">
              <label for="union-reduce">ユニオン補正(%)</label>
              <input id="union-reduce" type="number" min="0" max="10" step="1" value="10" />
          </div>
          <div class="input-row">
              <label for="hit-defender">敏捷</label>
              <input id="hit-defender" type="number" min="0" step="1" value="0" />
          </div>
          <div class="input-row">
              <label for="hit-dizzy-defender">眩暈Lv</label>
              <input id="hit-dizzy-defender" type="number" min="0" max="10" step="1" value="0" />
          </div>
          <label class="toggle-item mode-attack">
              <input id="def-hardening" type="checkbox" />
              <span>硬化Lv10</span>
          </label>
          <label class="toggle-item mode-attack">
              <input id="def-critical" type="checkbox" />
              <span>クリティカル</span>
          </label>
        </div>
      </div>
    </section>

    <section class="reveal">
      <div class="section-title">
        <h2>計算式</h2>
        <span>要検証</span>
      </div>
      <article class="card no-hover">
        <table class="formula-table">
          <tbody>
            <tr>
              <th>スキル強度</th>
              <td>`係数 × √(ソース平均 / 属性定数)`</td>
            </tr>
            <tr>
              <th>属性定数</th>
              <td>`物理=5 / 炎冷=9 / 虚軸=20`</td>
            </tr>
            <tr>
              <th>防御定数</th>
              <td>`通常: 物理500 / 炎冷120 / 虚軸10`<br>`硬化Lv10: 物理2000 / 炎冷0 / 虚軸0`<br>`クリティカル時: 物理(硬化あり500・なし0) / 炎冷0 / 虚軸0`</td>
            </tr>
            <tr>
              <th>防御強度</th>
              <td>`√(防御定数 × 防御) × (1 - 隙/100)`</td>
            </tr>
            <tr>
              <th>適正/耐性補正</th>
              <td>`耐性補正 = ((100-耐性P')/100) × ((100-耐性A')/100)`<br>`適正補正 = ((100+適正P')/100) × ((100+適正A')/100)`</td>
            </tr>
            <tr>
              <th>正規化</th>
              <td>`適正': <=-100 は -100、>100 は √(100×値)`<br>`耐性': <-100 は -√(-100×値)`</td>
            </tr>
            <tr>
              <th>ダメージ(乱数前)</th>
              <td>`(スキル強度 × 耐性補正 × 適正補正 × (1+強化/100) × (1-封技封術/10) - 防御強度) × (1-ユニオン/100)`</td>
            </tr>
            <tr>
              <th>乱数範囲</th>
              <td>`最小 = ダメージ×0.875 / 最大 = ダメージ×1.125`（表示は切り上げ）</td>
            </tr>
            <tr>
              <th>付与・回復</th>
              <td>`係数 × √(ソース平均×0.2) × 耐性補正 × 適正補正 × (1+強化/100) × (1-封技封術/10)`（表示は切り上げ）</td>
            </tr>
            <tr>
              <th>命中率</th>
              <td>`補正前命中率 = 70 + √5 × (スキル命中×(1-眩暈攻/10)×√攻命/100 - (1-隙/100)×(1-眩暈防/10)×√防敏)`<br>`補正後命中率 = 補正前命中率 × 後攻補正 × 君主補正`<br>`神眼あり: 30〜99 / なし: 20〜95 で丸め、最後に切り捨て`</td>
            </tr>
            <tr>
              <th>命中補正定数</th>
              <td>`後攻補正: 後攻なら2 / 通常なら1`<br>`君主補正: ありなら1.5 / なしなら1`</td>
            </tr>
          </tbody>
        </table>
        <p class="formula-note">付与でP適正とA適正両方がある場合など計算が合わないケースがあります。情報募集中</p>
      </article>
    </section>
  </main>

  <script>
    (() => {
      const RANDOM_MIN = 0.875;
      const RANDOM_MAX = 1.125;
      const STORAGE_KEY = "eldersign_damage_form_v1";

      const inputs = {
        skillType: document.getElementById("skill-type"),
        skillCoeff: document.getElementById("skill-coeff"),
        skillSource: document.getElementById("skill-source"),
        skillAttr: document.getElementById("skill-attr"),
        skillResistPassive: document.getElementById("skill-resist-passive"),
        skillResistActive: document.getElementById("skill-resist-active"),
        skillAptPassive: document.getElementById("skill-apt-passive"),
        skillAptActive: document.getElementById("skill-apt-active"),
        skillBuff: document.getElementById("skill-buff"),
        skillSeal: document.getElementById("skill-seal"),
        defValue: document.getElementById("def-value"),
        defAlert: document.getElementById("def-alert"),
        defHardening: document.getElementById("def-hardening"),
        defCritical: document.getElementById("def-critical"),
        unionReduce: document.getElementById("union-reduce"),
        hitSkill: document.getElementById("hit-skill"),
        hitAttacker: document.getElementById("hit-attacker"),
        hitDefender: document.getElementById("hit-defender"),
        hitDizzyAttacker: document.getElementById("hit-dizzy-attacker"),
        hitDizzyDefender: document.getElementById("hit-dizzy-defender"),
        hitAfter: document.getElementById("hit-after"),
        hitMonarch: document.getElementById("hit-monarch"),
        hitEye: document.getElementById("hit-eye"),
      };

      const outputs = {
        atkDamageBase: document.getElementById("atk-damage-base"),
        atkDamageRange: document.getElementById("atk-damage-range"),
        hitRaw: document.getElementById("hit-raw"),
        detailSkillPower: document.getElementById("detail-skill-power"),
        detailDefPower: document.getElementById("detail-def-power"),
        detailDamageMeta: document.getElementById("detail-damage-meta"),
        detailUnionMeta: document.getElementById("detail-union-meta"),
        detailHealMeta: document.getElementById("detail-heal-meta"),
        detailHitMeta: document.getElementById("detail-hit-meta"),
        resultSummary: document.getElementById("result-summary"),
        resultDetailPanel: document.getElementById("result-detail-panel"),
      };

      function readNumber(input) {
        const value = Number(input.value);
        return Number.isFinite(value) ? value : 0;
      }

      function formatNumber(value, digits = 1) {
        if (!Number.isFinite(value)) return "-";
        return value.toFixed(digits);
      }

      function formatDamage(value) {
        if (!Number.isFinite(value)) return "-";
        return String(Math.ceil(value));
      }

      function setChipValue(input, value) {
        if (!input || value == null) return;
        const strValue = String(value);
        input.value = strValue;
        const group = document.querySelector(`.chip-group[data-chip-target="${input.id}"]`);
        if (!group) return;
        group.querySelectorAll(".chip-button").forEach((button) => {
          const isActive = button.dataset.value === strValue;
          button.classList.toggle("is-active", isActive);
        });
      }

      function parseNumberList(text) {
        if (!text) return [];
        return text
          .split(/[,\s]+/)
          .map((v) => Number(v))
          .filter((v) => Number.isFinite(v));
      }

      function average(values) {
        if (values.length === 0) return 0;
        const sum = values.reduce((acc, v) => acc + v, 0);
        return sum / values.length;
      }

      function calcSkillPower() {
        const coeff = readNumber(inputs.skillCoeff);
        const sources = parseNumberList(inputs.skillSource.value);
        const avgSource = average(sources);
        const atkConst = getAttackConst(inputs.skillAttr.value);
        if (atkConst <= 0 || avgSource <= 0) {
          return { value: 0, meta: "ソースか定数が未入力のため0" };
        }
        const value = coeff * Math.sqrt(avgSource / atkConst);
        const meta = `ソース平均 ${formatNumber(avgSource, 1)} / 定数 ${atkConst}`;
        return { value, meta };
      }

      function getAttackConst(attr) {
        switch (attr) {
          case "physical":
            return 5;
          case "element":
            return 9;
          case "void":
            return 20;
          default:
            return 0;
        }
      }

      function getDefenseConst(attr) {
        switch (attr) {
          case "physical":
            return 500;
          case "element":
            return 120;
          case "void":
            return 10;
          default:
            return 0;
        }
      }

      function calcDefenseConst() {
        const baseConst = getDefenseConst(inputs.skillAttr.value);
        const isPhysical = inputs.skillAttr.value === "physical";
        const hardening = inputs.defHardening.checked;
        const critical = inputs.defCritical.checked;

        if (critical) {
          if (hardening && isPhysical) return 500;
          return 0;
        }
        if (hardening) {
          if (isPhysical) return 2000;
          return 0;
        }
        return baseConst;
      }

      function calcDefensePower() {
        const defConst = calcDefenseConst();
        const defense = readNumber(inputs.defValue);
        const alert = readNumber(inputs.defAlert);
        if (defConst <= 0 || defense <= 0) {
          return { value: 0, meta: "定数または防御が0のため0" };
        }
        const base = Math.sqrt(defConst * defense);
        const value = base * (1 - alert / 100);
        const meta = `定数 ${defConst} × 防御 ${formatNumber(defense, 0)} × 隙 ${formatNumber(
          100 - alert,
          1
        )}%`;
        return { value, meta };
      }

      function normalizeProper(value) {
        if (value <= -100) return -100;
        if (value > 100) return Math.sqrt(100 * value);
        return value;
      }

      function normalizeTolerant(value) {
        if (value < -100) return -Math.sqrt(-100 * value);
        return value;
      }

      function calcResAptMultiplier(resistP, resistA, aptP, aptA) {
        const tolerantP = normalizeTolerant(resistP);
        const tolerantA = normalizeTolerant(resistA);
        const properP = normalizeProper(aptP);
        const properA = normalizeProper(aptA);
        const resPctP = 100 - tolerantP;
        const resPctA = 100 - tolerantA;
        const aptPctP = 100 + properP;
        const aptPctA = 100 + properA;
        return {
          res: (resPctP / 100) * (resPctA / 100),
          apt: (aptPctP / 100) * (aptPctA / 100),
          resPctP,
          resPctA,
          aptPctP,
          aptPctA,
        };
      }

      function calcOtherMultiplier(buff) {
        return 1 + buff / 100;
      }

      function updateAttack() {
        const skill = calcSkillPower();
        const defense = calcDefensePower();

        const resistP = readNumber(inputs.skillResistPassive);
        const resistA = readNumber(inputs.skillResistActive);
        const aptP = readNumber(inputs.skillAptPassive);
        const aptA = readNumber(inputs.skillAptActive);
        const ra = calcResAptMultiplier(resistP, resistA, aptP, aptA);
        const other = calcOtherMultiplier(readNumber(inputs.skillBuff));
        const seal = readNumber(inputs.skillSeal);
        const sealMultiplier = 1 - seal / 10;

        const base = skill.value * ra.res * ra.apt * other * sealMultiplier - defense.value;
        const unionReduce = Math.min(10, Math.max(0, readNumber(inputs.unionReduce)));
        const unionMultiplier = 1 - unionReduce / 100;
        const unioned = base * unionMultiplier;

        outputs.atkDamageBase.textContent = formatDamage(unioned);
        outputs.detailSkillPower.textContent = formatNumber(skill.value, 1);
        outputs.detailDefPower.textContent = formatNumber(defense.value, 1);
        outputs.detailDamageMeta.textContent = `耐性${formatNumber(ra.resPctP, 1)}%×${formatNumber(
          ra.resPctA,
          1
        )}% 適正${formatNumber(ra.aptPctP, 1)}%×${formatNumber(ra.aptPctA, 1)}% 封${formatNumber(
          sealMultiplier * 100,
          1
        )}% 強化${formatNumber(other * 100, 1)}%`;
        outputs.detailUnionMeta.textContent = `${formatNumber(unionMultiplier * 100, 1)}%`;
        outputs.detailHealMeta.textContent = "-";

        const minDamage = unioned * RANDOM_MIN;
        const maxDamage = unioned * RANDOM_MAX;
        outputs.atkDamageRange.textContent = `${formatDamage(minDamage)} ～ ${formatDamage(maxDamage)}`;
      }

      function updateHeal() {
        const coeff = readNumber(inputs.skillCoeff);
        const sources = parseNumberList(inputs.skillSource.value);
        const avgSource = average(sources);
        const resistP = readNumber(inputs.skillResistPassive);
        const resistA = readNumber(inputs.skillResistActive);
        const aptP = readNumber(inputs.skillAptPassive);
        const aptA = readNumber(inputs.skillAptActive);
        const ra = calcResAptMultiplier(resistP, resistA, aptP, aptA);
        const other = calcOtherMultiplier(readNumber(inputs.skillBuff));
        const seal = readNumber(inputs.skillSeal);
        const sealMultiplier = 1 - seal / 10;

        const base = coeff * Math.sqrt(avgSource * 0.2) * ra.res * ra.apt * other * sealMultiplier;
        outputs.atkDamageBase.textContent = formatDamage(base);
        outputs.atkDamageRange.textContent = "-";
        outputs.detailSkillPower.textContent = "-";
        outputs.detailDefPower.textContent = "-";
        outputs.detailDamageMeta.textContent = "-";
        outputs.detailUnionMeta.textContent = "-";
        outputs.detailHealMeta.textContent = `耐性${formatNumber(ra.resPctP, 1)}%×${formatNumber(
          ra.resPctA,
          1
        )}% 適正${formatNumber(ra.aptPctP, 1)}%×${formatNumber(ra.aptPctA, 1)}% 封${formatNumber(
          sealMultiplier * 100,
          1
        )}% 強化${formatNumber(other * 100, 1)}%`;
      }

      function updateHit() {
        const skillHit = readNumber(inputs.hitSkill);
        const attackerHit = readNumber(inputs.hitAttacker);
        const defenderAgi = readNumber(inputs.hitDefender);
        const alert = readNumber(inputs.defAlert);
        const dizzyAttacker = readNumber(inputs.hitDizzyAttacker);
        const dizzyDefender = readNumber(inputs.hitDizzyDefender);
        const after = inputs.hitAfter.checked ? 2 : 1;
        const monarch = inputs.hitMonarch.checked ? 1.5 : 1;

        const raw =
          70 +
          Math.sqrt(5) *
            (skillHit *
              (1 - dizzyAttacker / 10) *
              (Math.sqrt(attackerHit) / 100) -
              (1 - alert / 100) * (1 - dizzyDefender / 10) * Math.sqrt(defenderAgi));
        const corrected = raw * after * monarch;
        const caps = inputs.hitEye.checked ? { max: 99, min: 30 } : { max: 95, min: 20 };
        const capped = Math.min(caps.max, Math.max(caps.min, corrected));
        const final = Math.floor(capped);

        outputs.hitRaw.textContent = `${formatNumber(final, 0)}%(${formatNumber(corrected, 2)}%)`;
        outputs.detailHitMeta.textContent = `補正前命中率=${formatNumber(raw, 2)} 補正後=${formatNumber(
          corrected,
          2
        )}`;
      }

      function updateAll() {
        updateModeUI();
        if (inputs.skillType.value === "attack") {
          updateAttack();
        } else {
          updateHeal();
        }
        updateHit();
        saveFormState();
      }

      function saveFormState() {
        const state = {};
        Object.entries(inputs).forEach(([key, input]) => {
          if (!input) return;
          state[key] = input.type === "checkbox" ? input.checked : input.value;
        });
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (error) {
          // Ignore storage failures (private mode, quota, etc.)
        }
      }

      function loadFormState() {
        let state = null;
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          state = raw ? JSON.parse(raw) : null;
        } catch (error) {
          state = null;
        }
        if (!state || typeof state !== "object") return;
        Object.entries(inputs).forEach(([key, input]) => {
          if (!input || !(key in state)) return;
          if (input.type === "checkbox") {
            input.checked = Boolean(state[key]);
            return;
          }
          input.value = String(state[key]);
        });
        setChipValue(inputs.skillType, inputs.skillType.value);
        setChipValue(inputs.skillAttr, inputs.skillAttr.value);
      }

      function updateModeUI() {
        const isAttack = inputs.skillType.value === "attack";
        document.querySelectorAll(".mode-attack").forEach((el) => {
          el.classList.toggle("is-hidden", !isAttack);
        });
        document.querySelectorAll(".mode-heal").forEach((el) => {
          el.classList.toggle("is-hidden", isAttack);
        });
      }

      function setResultDetailOpen(open) {
        outputs.resultDetailPanel.classList.toggle("is-hidden", !open);
        outputs.resultSummary.setAttribute("aria-expanded", open ? "true" : "false");
      }

      Object.values(inputs).forEach((input) => {
        if (!input) return;
        const eventName = input.type === "checkbox" ? "change" : "input";
        input.addEventListener(eventName, updateAll);
      });

      document.querySelectorAll(".chip-group").forEach((group) => {
        group.addEventListener("click", (event) => {
          const button = event.target.closest(".chip-button");
          if (!button || !group.contains(button)) return;
          const targetId = group.dataset.chipTarget;
          if (!targetId) return;
          const input = document.getElementById(targetId);
          if (!input) return;
          setChipValue(input, button.dataset.value);
          updateAll();
        });
      });

      outputs.resultSummary.addEventListener("click", () => {
        const isOpen = !outputs.resultDetailPanel.classList.contains("is-hidden");
        setResultDetailOpen(!isOpen);
      });
      outputs.resultSummary.addEventListener("keydown", (event) => {
        if (event.key !== "Enter" && event.key !== " ") return;
        event.preventDefault();
        const isOpen = !outputs.resultDetailPanel.classList.contains("is-hidden");
        setResultDetailOpen(!isOpen);
      });

      loadFormState();
      setResultDetailOpen(false);
      updateAll();
    })();
  </script>
  <script src="../footer.js" defer></script>
</body>

</html>
